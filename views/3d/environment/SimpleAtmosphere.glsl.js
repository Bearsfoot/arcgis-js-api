// COPYRIGHT Â© 2020 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.15/esri/copyright.txt for details.

define(["require","exports","../../../core/tsSupport/makeTemplateObjectHelper","../../../core/tsSupport/generatorHelper","../../../core/tsSupport/awaiterHelper","../webgl-engine/core/shaderLibrary/Transform.glsl","../webgl-engine/core/shaderModules/interfaces","../webgl-engine/core/shaderModules/ShaderBuilder"],(function(t,o,n,e,i,r,l,a){var d,s,c,g,p,v,f,m,h,x;Object.defineProperty(o,"__esModule",{value:!0}),o.build=function(t){var o=new a.ShaderBuilder;return 2===t.geometry?(o.attributes.add("position","vec2"),o.varyings.add("color","vec4"),o.vertex.uniforms.add("lightingMainDirection","vec3").add("cameraPosition","vec3").add("undergroundFadeAlpha","float"),o.vertex.code.add(l.glsl(d||(d=n(["\n      void main(void) {\n          float ndotl = dot(normalize(cameraPosition), -lightingMainDirection);\n          float lighting = max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));\n\n          color = vec4(vec3(lighting), undergroundFadeAlpha);\n\n          gl_Position = vec4(position.xy, 1.0, 1.0); // on the far plane\n      }\n  "],["\n      void main(void) {\n          float ndotl = dot(normalize(cameraPosition), -lightingMainDirection);\n          float lighting = max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));\n\n          color = vec4(vec3(lighting), undergroundFadeAlpha);\n\n          gl_Position = vec4(position.xy, 1.0, 1.0); // on the far plane\n      }\n  "])))),o.fragment.code.add(l.glsl(s||(s=n(["\n      void main() {\n          gl_FragColor = color;\n      }\n  "],["\n      void main() {\n          gl_FragColor = color;\n      }\n  "]))))):(o.include(r.Transform,{linearDepth:!1}),o.attributes.add("position","vec3"),o.varyings.add("vtc","vec2"),o.varyings.add("falloff","float"),1!==t.geometry&&o.varyings.add("innerFactor","float"),o.vertex.uniforms.add("proj","mat4").add("view","mat4").add("lightingMainDirection","vec3"),1!==t.geometry&&o.vertex.uniforms.add("silCircleCenter","vec3").add("silCircleV1","vec3").add("silCircleV2","vec3").add("texV","vec2").add("innerScale","float"),1!==t.geometry&&o.vertex.code.add(l.glsl(c||(c=n(["\n\t\t\tconst float TWICEPI = 2.0*3.14159265;\n\t\t\tconst float ATMOSPHERE_RIM_SEGMENTS = 128.0;\n\t\t"],["\n\t\t\tconst float TWICEPI = 2.0*3.14159265;\n\t\t\tconst float ATMOSPHERE_RIM_SEGMENTS = 128.0;\n\t\t"])))),o.vertex.code.add(l.glsl(g||(g=n(["\n\t\tvoid main(void) {\n\t\t\tvec3 lightDirection = -lightingMainDirection;\n\t"],["\n\t\tvoid main(void) {\n\t\t\tvec3 lightDirection = -lightingMainDirection;\n\t"])))),1===t.geometry?o.vertex.code.add(l.glsl(p||(p=n(["\n\t\t\tvec3 pos = position;\n\t\t\tfloat ndotl = lightDirection.z;\n\t\t\tvtc = vec2(0.0, position.z+0.05);\n\t\t\t"],["\n\t\t\tvec3 pos = position;\n\t\t\tfloat ndotl = lightDirection.z;\n\t\t\tvtc = vec2(0.0, position.z+0.05);\n\t\t\t"])))):o.vertex.code.add(l.glsl(v||(v=n(["\n\t\t\tinnerFactor = clamp(-position.z, 0.0, 1.0);\n\t\t\tfloat scale = position.y * (1.0 + innerFactor * innerScale);\n\t\t\tfloat phi = position.x * (TWICEPI / ATMOSPHERE_RIM_SEGMENTS) + 1.0;\n\t\t\tvec3 pos =  (silCircleCenter + sin(phi) * silCircleV1 + cos(phi) * silCircleV2) * scale;\n\t\t\tfloat ndotl = dot(normalize(position.y > 0.0 ? pos: silCircleCenter), lightDirection);\n\n\t\t\tvtc.x = position.x / ATMOSPHERE_RIM_SEGMENTS;\n\t\t\tvtc.y = texV.x * (1.0 - position.z) + texV.y * position.z;\n\t\t"],["\n\t\t\tinnerFactor = clamp(-position.z, 0.0, 1.0);\n\t\t\tfloat scale = position.y * (1.0 + innerFactor * innerScale);\n\t\t\tfloat phi = position.x * (TWICEPI / ATMOSPHERE_RIM_SEGMENTS) + 1.0;\n\t\t\tvec3 pos =  (silCircleCenter + sin(phi) * silCircleV1 + cos(phi) * silCircleV2) * scale;\n\t\t\tfloat ndotl = dot(normalize(position.y > 0.0 ? pos: silCircleCenter), lightDirection);\n\n\t\t\tvtc.x = position.x / ATMOSPHERE_RIM_SEGMENTS;\n\t\t\tvtc.y = texV.x * (1.0 - position.z) + texV.y * position.z;\n\t\t"])))),o.vertex.code.add(l.glsl(f||(f=n(["\n\t\tfalloff = max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));\n\n\t\tgl_Position = transformPosition(proj, view, pos);\n\t\tgl_Position.z = gl_Position.w; // project atmosphere onto the far plane\n\t\t\t}\n\t"],["\n\t\tfalloff = max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));\n\n\t\tgl_Position = transformPosition(proj, view, pos);\n\t\tgl_Position.z = gl_Position.w; // project atmosphere onto the far plane\n\t\t\t}\n\t"])))),o.fragment.uniforms.add("tex","sampler2D"),1!==t.geometry&&o.fragment.uniforms.add("altitudeFade","float"),o.fragment.code.add(l.glsl(m||(m=n(["\n\t\tvoid main() {\n\t\t\tvec4 texColor = texture2D(tex, vtc);\n\t"],["\n\t\tvoid main() {\n\t\t\tvec4 texColor = texture2D(tex, vtc);\n\t"])))),1===t.geometry?o.fragment.code.add(l.glsl(h||(h=n(["\n\t\t\tgl_FragColor = texColor * falloff;\n\t\t\t}\n\t\t"],["\n\t\t\tgl_FragColor = texColor * falloff;\n\t\t\t}\n\t\t"])))):o.fragment.code.add(l.glsl(x||(x=n(["\n\t\t\tvec4 atmosphereColor = texColor * falloff;\n\t\t\tvec4 innerColor = vec4(texColor.rgb * falloff, 1.0 - altitudeFade);\n\t\t\tgl_FragColor = mix(atmosphereColor, innerColor, smoothstep(0.0, 1.0, innerFactor));\n\t\t}\n\t\t"],["\n\t\t\tvec4 atmosphereColor = texColor * falloff;\n\t\t\tvec4 innerColor = vec4(texColor.rgb * falloff, 1.0 - altitudeFade);\n\t\t\tgl_FragColor = mix(atmosphereColor, innerColor, smoothstep(0.0, 1.0, innerFactor));\n\t\t}\n\t\t"]))))),o}}));