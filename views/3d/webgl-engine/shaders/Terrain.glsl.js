// COPYRIGHT Â© 2020 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.15/esri/copyright.txt for details.

define(["require","exports","../../../../core/tsSupport/makeTemplateObjectHelper","../core/shaderLibrary/Slice.glsl","../core/shaderLibrary/Transform.glsl","../core/shaderLibrary/output/OutputDepth.glsl","../core/shaderLibrary/output/OutputHighlight.glsl","../core/shaderLibrary/shading/EvaluateSceneLighting.glsl","../core/shaderLibrary/shading/NormalUtils.glsl","../core/shaderLibrary/util/RgbaFloatEncoding.glsl","../core/shaderModules/interfaces","../core/shaderModules/ShaderBuilder","./Overlay.glsl","./Skirts.glsl"],(function(e,n,o,a,r,l,t,i,v,s,c,d,m,g){var p,u,f,h,C,x,b,y,w,S,z,F,_,O,D,T,P,L,k,N,M,A,E,W,B,j,U;Object.defineProperty(n,"__esModule",{value:!0}),n.build=function(e){var n=new d.ShaderBuilder;return n.include(g.Skirts),n.attributes.add("position","vec3"),n.attributes.add("uv0","vec2"),n.vertex.uniforms.add("proj","mat4").add("view","mat4").add("origin","vec3").add("skirtScale","float"),0===e.output&&(n.include(r.Transform,{linearDepth:!1}),n.include(v.NormalUtils,e),e.overlayEnabled&&n.include(m.Overlay,{pbrMode:3,useCustomDTRExponentForWater:!1}),n.varyings.add("vnormal","vec3"),n.varyings.add("vpos","vec3"),n.varyings.add("vtc","vec2"),n.vertex.uniforms.add("viewNormal","mat4"),n.vertex.uniforms.add("texOffsetAndScale","vec4"),n.vertex.uniforms.add("oldTexOffsetAndScale","vec4"),e.receiveShadows&&n.varyings.add("linearDepth","float"),e.tileBorders&&n.varyings.add("vuv","vec2"),e.atmosphere&&(n.vertex.uniforms.add("lightingMainDirection","vec3"),n.varyings.add("wnormal","vec3"),n.varyings.add("wlight","vec3")),e.overlayEnabled&&(n.varyings.add("tbnTangent","vec3"),n.varyings.add("tbnBiTangent","vec3")),e.textureFadingEnabled&&n.varyings.add("ovtc","vec2"),e.screenSizePerspective&&(n.vertex.uniforms.add("screenSizePerspective","vec4"),n.varyings.add("screenSizeDistanceToCamera","float"),n.varyings.add("screenSizeCosAngle","float")),n.vertex.code.add(c.glsl(w||(w=o(["\n      void main(void) {\n        vpos = position;\n        vnormal = getLocalUp(vpos, origin);\n\n        vec2 uv = uv0;\n        vpos = applySkirts(uv, vpos, vnormal, skirtScale);\n        ","\n        ","\n        ","\n        gl_Position = transformPosition(proj, view, vpos);\n        ","\n        vtc = uv * texOffsetAndScale.zw + texOffsetAndScale.xy;\n        ","\n        ","\n      }\n    "],["\n      void main(void) {\n        vpos = position;\n        vnormal = getLocalUp(vpos, origin);\n\n        vec2 uv = uv0;\n        vpos = applySkirts(uv, vpos, vnormal, skirtScale);\n        ","\n        ","\n        ","\n        gl_Position = transformPosition(proj, view, vpos);\n        ","\n        vtc = uv * texOffsetAndScale.zw + texOffsetAndScale.xy;\n        ","\n        ","\n      }\n    "])),e.atmosphere?c.glsl(p||(p=o(["\n        wnormal = (viewNormal * vec4(normalize(vpos+origin), 1.0)).xyz;\n        wlight = (view  * vec4(-lightingMainDirection, 1.0)).xyz;"],["\n        wnormal = (viewNormal * vec4(normalize(vpos+origin), 1.0)).xyz;\n        wlight = (view  * vec4(-lightingMainDirection, 1.0)).xyz;"]))):"",e.tileBorders?c.glsl(u||(u=o(["vuv = uv;"],["vuv = uv;"]))):"",e.screenSizePerspective?c.glsl(f||(f=o(["\n        vec3 viewPos = (view * vec4(vpos, 1.0)).xyz;\n        screenSizeDistanceToCamera = length(viewPos);\n        vec3 viewSpaceNormal = (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n        screenSizeCosAngle = abs(viewSpaceNormal.z);"],["\n        vec3 viewPos = (view * vec4(vpos, 1.0)).xyz;\n        screenSizeDistanceToCamera = length(viewPos);\n        vec3 viewSpaceNormal = (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\n        screenSizeCosAngle = abs(viewSpaceNormal.z);"]))):"",e.receiveShadows?c.glsl(h||(h=o(["linearDepth = gl_Position.w;"],["linearDepth = gl_Position.w;"]))):"",e.overlayEnabled?c.glsl(b||(b=o(["\n        setOverlayVTC(uv);\n        ","\n        "],["\n        setOverlayVTC(uv);\n        ","\n        "])),0===e.viewingMode?c.glsl(C||(C=o(["\n        tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), vnormal));\n        tbnBiTangent = normalize(cross(vnormal, tbnTangent));"],["\n        tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), vnormal));\n        tbnBiTangent = normalize(cross(vnormal, tbnTangent));"]))):c.glsl(x||(x=o(["\n        tbnTangent = vec3(1.0, 0.0, 0.0);\n        tbnBiTangent = normalize(cross(vnormal, tbnTangent));"],["\n        tbnTangent = vec3(1.0, 0.0, 0.0);\n        tbnBiTangent = normalize(cross(vnormal, tbnTangent));"])))):"",e.textureFadingEnabled?c.glsl(y||(y=o(["\n        ovtc = uv * oldTexOffsetAndScale.zw + oldTexOffsetAndScale.xy;"],["\n        ovtc = uv * oldTexOffsetAndScale.zw + oldTexOffsetAndScale.xy;"]))):"")),n.extensions.add("GL_OES_standard_derivatives"),n.extensions.add("GL_EXT_shader_texture_lod"),n.include(a.Slice,e),n.include(i.EvaluateSceneLighting,e),n.fragment.uniforms.add("camPos","vec3").add("viewDirection","vec3").add("ssaoTex","sampler2D").add("viewportPixelSz","vec4").add("tex","sampler2D").add("opacity","float"),e.screenSizePerspective&&n.fragment.uniforms.add("screenSizePerspective","vec4"),e.overlayEnabled&&(n.fragment.uniforms.add("ovInnerWaterTex","sampler2D"),n.fragment.uniforms.add("ovOuterWaterTex","sampler2D")),e.textureFadingEnabled&&n.fragment.uniforms.add("texOld","sampler2D").add("textureFadeFactor","float"),n.fragment.code.add(c.glsl(S||(S=o(["\n      const vec3 ambient = vec3(0.2, 0.2, 0.2);\n      const vec3 diffuse = vec3(0.8, 0.8, 0.8);\n      const float diffuseHardness = 2.5;\n      const float sliceOpacity = 0.2;\n\n      float lum(vec3 c) {\n        float max = max(max(c.r, c.g), c.b);\n        float min = min(min(c.r, c.g), c.b);\n        return (min + max) * 0.5;\n      }\n      "],["\n      const vec3 ambient = vec3(0.2, 0.2, 0.2);\n      const vec3 diffuse = vec3(0.8, 0.8, 0.8);\n      const float diffuseHardness = 2.5;\n      const float sliceOpacity = 0.2;\n\n      float lum(vec3 c) {\n        float max = max(max(c.r, c.g), c.b);\n        float min = min(min(c.r, c.g), c.b);\n        return (min + max) * 0.5;\n      }\n      "])))),e.atmosphere&&n.fragment.code.add(c.glsl(z||(z=o(["\n      vec3 atmosphere(vec3 lightPos, vec3 normal, vec3 view) {\n        vec3 surfaceColor   = vec3(0.0);\n        vec3 fuzzySpecColor = vec3(1.0);\n        vec3 subColor       = vec3(0.0);\n        float rollOff       = 1.0;\n\n        vec3 Ln = normalize(lightPos);\n        vec3 Nn = normalize(normal);\n        vec3 Hn = normalize(view + Ln);\n\n        float ldn = dot(Ln, Nn);\n        float diffComp = max(0.0, ldn);\n        // clamp necessary here because values might cause flickering: #21549\n        float vdn = clamp(1.0 - dot(view, Nn), 0.0, 1.0);\n        float ndv = dot(view, Ln);\n\n        vec3 diffContrib = surfaceColor * diffComp;\n        float subLamb = max(0.0, smoothstep(-rollOff, 1.0, ldn) - smoothstep(0.0, 1.0, ldn));\n\n        vec3 subContrib = subLamb * subColor;\n        vec3 vecColor = vec3(vdn);\n\n        vec3 diffuseContrib = (subContrib + diffContrib);\n        vec3 specularContrib = (vecColor * fuzzySpecColor);\n\n        return (diffContrib + specularContrib) * rollOff;\n      }\n      "],["\n      vec3 atmosphere(vec3 lightPos, vec3 normal, vec3 view) {\n        vec3 surfaceColor   = vec3(0.0);\n        vec3 fuzzySpecColor = vec3(1.0);\n        vec3 subColor       = vec3(0.0);\n        float rollOff       = 1.0;\n\n        vec3 Ln = normalize(lightPos);\n        vec3 Nn = normalize(normal);\n        vec3 Hn = normalize(view + Ln);\n\n        float ldn = dot(Ln, Nn);\n        float diffComp = max(0.0, ldn);\n        // clamp necessary here because values might cause flickering: #21549\n        float vdn = clamp(1.0 - dot(view, Nn), 0.0, 1.0);\n        float ndv = dot(view, Ln);\n\n        vec3 diffContrib = surfaceColor * diffComp;\n        float subLamb = max(0.0, smoothstep(-rollOff, 1.0, ldn) - smoothstep(0.0, 1.0, ldn));\n\n        vec3 subContrib = subLamb * subColor;\n        vec3 vecColor = vec3(vdn);\n\n        vec3 diffuseContrib = (subContrib + diffContrib);\n        vec3 specularContrib = (vecColor * fuzzySpecColor);\n\n        return (diffContrib + specularContrib) * rollOff;\n      }\n      "])))),n.fragment.code.add(c.glsl(M||(M=o(["\n      void main() {\n        ","\n        float vndl = dot(normalize(vnormal), -lightingMainDirection);\n        float k = smoothstep(0.0, 1.0, clamp(vndl*diffuseHardness, 0.0, 1.0));\n        vec3 d = (1.0 - shadow/1.8) * diffuse * k;\n\n        float ssao = viewportPixelSz.w < .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n        ","\n        ","\n        if (rejectBySlice(vpos)) {\n          tileColor *= sliceOpacity;\n        }\n        vec3 atm = vec3(0.0);\n        ","\n        vec3 albedo = atm + tileColor.rgb;\n        vec3 normal = normalize(vnormal);\n\n        // heuristic shading function used in the old terrain, now used to add ambient lighting\n        float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n        gl_FragColor = vec4(evaluateSceneLightingExt(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);\n        ","\n        ","\n        ","\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    "],["\n      void main() {\n        ","\n        float vndl = dot(normalize(vnormal), -lightingMainDirection);\n        float k = smoothstep(0.0, 1.0, clamp(vndl*diffuseHardness, 0.0, 1.0));\n        vec3 d = (1.0 - shadow/1.8) * diffuse * k;\n\n        float ssao = viewportPixelSz.w < .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\n        ","\n        ","\n        if (rejectBySlice(vpos)) {\n          tileColor *= sliceOpacity;\n        }\n        vec3 atm = vec3(0.0);\n        ","\n        vec3 albedo = atm + tileColor.rgb;\n        vec3 normal = normalize(vnormal);\n\n        // heuristic shading function used in the old terrain, now used to add ambient lighting\n        float additionalAmbientScale = smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n\n        gl_FragColor = vec4(evaluateSceneLightingExt(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);\n        ","\n        ","\n        ","\n        gl_FragColor = highlightSlice(gl_FragColor, vpos);\n      }\n    "])),e.receiveShadows?c.glsl(F||(F=o(["float shadow = readShadowMap(vpos, linearDepth);"],["float shadow = readShadowMap(vpos, linearDepth);"]))):c.glsl(_||(_=o(["float shadow = 0.0;"],["float shadow = 0.0;"]))),e.textureFadingEnabled?c.glsl(O||(O=o(["vec4 tileColor = (textureFadeFactor < 1.0 ? mix(texture2D(texOld, ovtc), texture2D(tex, vtc), textureFadeFactor) : texture2D(tex, vtc)) * opacity;"],["vec4 tileColor = (textureFadeFactor < 1.0 ? mix(texture2D(texOld, ovtc), texture2D(tex, vtc), textureFadeFactor) : texture2D(tex, vtc)) * opacity;"]))):c.glsl(D||(D=o(["vec4 tileColor = texture2D(tex, vtc) * opacity;"],["vec4 tileColor = texture2D(tex, vtc) * opacity;"]))),e.overlayEnabled?c.glsl(T||(T=o(["vec4 overlayColor = getCombinedOverlayColor();\n            tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;"],["vec4 overlayColor = getCombinedOverlayColor();\n            tileColor = tileColor * (1.0 - overlayColor.a) + overlayColor;"]))):"",e.atmosphere?c.glsl(P||(P=o(["\n            float ndotl = max(0.0, min(1.0, vndl));\n            atm = atmosphere(wlight, wnormal, -viewDirection);\n            atm *= max(0.0, min(1.0, (1.0-lum(tileColor.rgb)*1.5))); //avoid atmosphere on bright base maps\n            atm *= max(0.0, min(1.0, ndotl*2.0)); // avoid atmosphere on dark side of the globe\n            atm *= tileColor.a; // premultiply with tile alpha"],["\n            float ndotl = max(0.0, min(1.0, vndl));\n            atm = atmosphere(wlight, wnormal, -viewDirection);\n            atm *= max(0.0, min(1.0, (1.0-lum(tileColor.rgb)*1.5))); //avoid atmosphere on bright base maps\n            atm *= max(0.0, min(1.0, ndotl*2.0)); // avoid atmosphere on dark side of the globe\n            atm *= tileColor.a; // premultiply with tile alpha"]))):"",e.overlayEnabled?c.glsl(L||(L=o(["\n            vec4 overlayWaterMask = getOverlayColor(ovInnerWaterTex, ovOuterWaterTex, vtcOverlay);\n            float waterNormalLength = length(overlayWaterMask);\n            if (waterNormalLength > 0.95) {\n              mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);\n              vec4 waterColor = overlayOpacity * getOverlayWaterColor(overlayWaterMask, overlayColor, -normalize(vpos - camPos), shadow, vnormal, tbnMatrix);\n              // un-gamma the ground color to mix in linear space\n              vec4 groundColor = vec4(pow(gl_FragColor.rgb, vec3(2.2)), gl_FragColor.w);\n              waterColor = mix(groundColor, waterColor, waterColor.a);\n              gl_FragColor = delinearizeGamma(waterColor);\n            }"],["\n            vec4 overlayWaterMask = getOverlayColor(ovInnerWaterTex, ovOuterWaterTex, vtcOverlay);\n            float waterNormalLength = length(overlayWaterMask);\n            if (waterNormalLength > 0.95) {\n              mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, vnormal);\n              vec4 waterColor = overlayOpacity * getOverlayWaterColor(overlayWaterMask, overlayColor, -normalize(vpos - camPos), shadow, vnormal, tbnMatrix);\n              // un-gamma the ground color to mix in linear space\n              vec4 groundColor = vec4(pow(gl_FragColor.rgb, vec3(2.2)), gl_FragColor.w);\n              waterColor = mix(groundColor, waterColor, waterColor.a);\n              gl_FragColor = delinearizeGamma(waterColor);\n            }"]))):"",e.screenSizePerspective?c.glsl(k||(k=o(["\n          float perspectiveScale = screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);\n          if (perspectiveScale <= 0.25) {\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n          }\n          else if (perspectiveScale <= 0.5) {\n            gl_FragColor = mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n          }\n          else if (perspectiveScale >= 0.99) {\n            gl_FragColor = mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n          }\n          else {\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n          }"],["\n          float perspectiveScale = screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);\n          if (perspectiveScale <= 0.25) {\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\n          }\n          else if (perspectiveScale <= 0.5) {\n            gl_FragColor = mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\n          }\n          else if (perspectiveScale >= 0.99) {\n            gl_FragColor = mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\n          }\n          else {\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\n          }"]))):"",e.tileBorders?c.glsl(N||(N=o(["\n            vec2 dVuv = fwidth(vuv);\n            vec2 edgeFactors = smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv, 1.0 - vuv));\n            float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);"],["\n            vec2 dVuv = fwidth(vuv);\n            vec2 edgeFactors = smoothstep(vec2(0.0), 1.5 * dVuv, min(vuv, 1.0 - vuv));\n            float edgeFactor = 1.0 - min(edgeFactors.x, edgeFactors.y);\n            gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);"]))):""))),1!==e.output&&3!==e.output||(n.include(r.Transform,{linearDepth:!0}),n.include(s.RgbaFloatEncoding),n.include(l.OutputDepth,{output:e.output}),n.include(v.NormalUtils,e),n.varyings.add("linearDepth","float"),n.vertex.uniforms.add("nearFar","vec2"),n.vertex.code.add(c.glsl(A||(A=o(["\n        void main(void) {\n          vec3 normal = getLocalUp(position, origin);\n          vec2 uv = uv0;\n          vec3 vpos = applySkirts(uv, position, normal.xyz, skirtScale);\n\n          gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);\n        }\n    "],["\n        void main(void) {\n          vec3 normal = getLocalUp(position, origin);\n          vec2 uv = uv0;\n          vec3 vpos = applySkirts(uv, position, normal.xyz, skirtScale);\n\n          gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);\n        }\n    "])))),n.fragment.code.add(c.glsl(E||(E=o(["\n        void main() {\n          outputDepth(linearDepth);\n        }\n    "],["\n        void main() {\n          outputDepth(linearDepth);\n        }\n    "]))))),2===e.output&&(n.include(r.Transform,{linearDepth:!1}),n.include(v.NormalUtils,e),n.varyings.add("vnormal","vec3"),n.varyings.add("vpos","vec3"),n.vertex.uniforms.add("viewNormal","mat4"),n.vertex.code.add(c.glsl(W||(W=o(["\n        void main(void) {\n          vec3 normal = getLocalUp(position, origin);\n          vec2 uv = uv0;\n          vpos = applySkirts(uv, position, normal, skirtScale);\n\n          gl_Position = transformPosition(proj, view, vpos);\n          vnormal = normalize((viewNormal * vec4(normal, 1.0)).xyz);\n        }\n    "],["\n        void main(void) {\n          vec3 normal = getLocalUp(position, origin);\n          vec2 uv = uv0;\n          vpos = applySkirts(uv, position, normal, skirtScale);\n\n          gl_Position = transformPosition(proj, view, vpos);\n          vnormal = normalize((viewNormal * vec4(normal, 1.0)).xyz);\n        }\n    "])))),n.fragment.code.add(c.glsl(B||(B=o(["\n        void main() {\n          vec3 normal = normalize(vnormal);\n          if (gl_FrontFacing == false) {\n            normal = -normal;\n          }\n          gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 0.0);\n        }\n    "],["\n        void main() {\n          vec3 normal = normalize(vnormal);\n          if (gl_FrontFacing == false) {\n            normal = -normal;\n          }\n          gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 0.0);\n        }\n    "]))))),4===e.output&&(n.include(r.Transform,{linearDepth:!1}),n.include(v.NormalUtils,e),n.include(m.Overlay,{pbrMode:0}),n.vertex.code.add(c.glsl(j||(j=o(["\n          void main() {\n            vec3 vnormal = getLocalUp(position, origin);\n            vec2 uv = uv0;\n            vec3 vpos = applySkirts(uv, position, vnormal, skirtScale);\n            setOverlayVTC(uv);\n\n            gl_Position = transformPosition(proj, view, vpos);\n          }\n      "],["\n          void main() {\n            vec3 vnormal = getLocalUp(position, origin);\n            vec2 uv = uv0;\n            vec3 vpos = applySkirts(uv, position, vnormal, skirtScale);\n            setOverlayVTC(uv);\n\n            gl_Position = transformPosition(proj, view, vpos);\n          }\n      "])))),n.include(t.OutputHighlight),n.fragment.code.add(c.glsl(U||(U=o(["\n        void main() {\n          vec4 overlayColor = getCombinedOverlayColor();\n\n          if (overlayColor.a == 0.0) {\n            gl_FragColor = vec4(0.0);\n            return;\n          }\n\n          outputHighlight();\n        }\n      "],["\n        void main() {\n          vec4 overlayColor = getCombinedOverlayColor();\n\n          if (overlayColor.a == 0.0) {\n            gl_FragColor = vec4(0.0);\n            return;\n          }\n\n          outputHighlight();\n        }\n      "]))))),n}}));