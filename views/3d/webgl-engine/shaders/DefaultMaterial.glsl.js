// COPYRIGHT Â© 2020 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.15/esri/copyright.txt for details.

define(["require","exports","../../../../core/tsSupport/makeTemplateObjectHelper","../core/shaderLibrary/ForwardLinearDepth.glsl","../core/shaderLibrary/Offset.glsl","../core/shaderLibrary/Slice.glsl","../core/shaderLibrary/Transform.glsl","../core/shaderLibrary/attributes/InstancedDoublePrecision.glsl","../core/shaderLibrary/attributes/NormalAttribute.glsl","../core/shaderLibrary/attributes/PositionAttribute.glsl","../core/shaderLibrary/attributes/SymbolColor.glsl","../core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl","../core/shaderLibrary/attributes/VertexColor.glsl","../core/shaderLibrary/attributes/VertexNormal.glsl","../core/shaderLibrary/attributes/VerticalOffset.glsl","../core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl","../core/shaderLibrary/shading/ComputeNormalTexture.glsl","../core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl","../core/shaderLibrary/shading/EvaluateSceneLighting.glsl","../core/shaderLibrary/shading/Normals.glsl","../core/shaderLibrary/shading/PhysicallyBasedRendering.glsl","../core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl","../core/shaderLibrary/shading/ReadShadowMap.glsl","../core/shaderLibrary/shading/VisualVariables.glsl","../core/shaderLibrary/util/AlphaDiscard.glsl","../core/shaderLibrary/util/MixExternalColor.glsl","../core/shaderModules/interfaces","../core/shaderModules/ShaderBuilder"],(function(a,o,e,r,l,i,n,t,s,d,c,v,g,m,u,h,p,x,b,y,f,C,M,L,P,O,w,S){var N,A,E,_,T,D,V,B,I,F,G,R,j,z;Object.defineProperty(o,"__esModule",{value:!0}),o.build=function(a){var o=new S.ShaderBuilder,k=o.vertex.code,W=o.fragment.code;return o.vertex.uniforms.add("proj","mat4").add("view","mat4").add("camPos","vec3").add("localOrigin","vec3"),o.include(d.PositionAttribute),o.varyings.add("vpos","vec3"),o.include(L.VisualVariables,a),o.include(t.InstancedDoublePrecision,a),o.include(u.VerticalOffset,a),0===a.output&&(o.include(s.NormalAttribute,a),o.include(n.Transform,{linearDepth:!1}),0===a.normalType&&a.offsetBackfaces&&o.include(l.Offset),o.include(p.ComputeNormalTexture,a),o.include(m.VertexNormal,a),a.instancedColor&&o.attributes.add("instanceColor","vec4"),o.varyings.add("localvpos","vec3"),o.include(v.TextureCoordinateAttribute,a),o.include(r.ForwardLinearDepth,a),o.include(c.SymbolColor,a),o.include(g.VertexColor,a),o.vertex.uniforms.add("externalColor","vec4"),o.varyings.add("vcolorExt","vec4"),k.add(w.glsl(A||(A=e(["\n      void main(void) {\n        forwardNormalizedVertexColor();\n        vcolorExt = externalColor;\n        ","\n        vcolorExt *= vvColor();\n        vcolorExt *= getSymbolColor();\n        forwardColorMixMode();\n\n        if (vcolorExt.a < ",") {\n          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        }\n        else {\n          vpos = calculateVPos();\n          localvpos = vpos - view[3].xyz;\n          vpos = subtractOrigin(vpos);\n          ","\n          vpos = addVerticalOffset(vpos, localOrigin);\n          ","\n          gl_Position = transformPosition(proj, view, vpos);\n          ","\n        }\n        forwardLinearDepth();\n        forwardTextureCoordinates();\n      }\n    "],["\n      void main(void) {\n        forwardNormalizedVertexColor();\n        vcolorExt = externalColor;\n        ","\n        vcolorExt *= vvColor();\n        vcolorExt *= getSymbolColor();\n        forwardColorMixMode();\n\n        if (vcolorExt.a < ",") {\n          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        }\n        else {\n          vpos = calculateVPos();\n          localvpos = vpos - view[3].xyz;\n          vpos = subtractOrigin(vpos);\n          ","\n          vpos = addVerticalOffset(vpos, localOrigin);\n          ","\n          gl_Position = transformPosition(proj, view, vpos);\n          ","\n        }\n        forwardLinearDepth();\n        forwardTextureCoordinates();\n      }\n    "])),a.instancedColor?"vcolorExt *= instanceColor;":"",w.glsl.float(P.symbolAlphaCutoff),0===a.normalType?w.glsl(N||(N=e(["\n          vNormalWorld = dpNormal(vvLocalNormal(normalModel()));"],["\n          vNormalWorld = dpNormal(vvLocalNormal(normalModel()));"]))):"",a.vertexTangets?"transformVertexTangent(mat3(modelNormal));":"",0===a.normalType&&a.offsetBackfaces?"gl_Position = offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, camPos);":"")),o.include(i.Slice,a),o.include(b.EvaluateSceneLighting,a),o.include(x.EvaluateAmbientOcclusion,a),o.include(P.DiscardOrAdjustAlpha,a),a.receiveShadows&&o.include(M.ReadShadowMap,a),o.fragment.uniforms.add("camPos","vec3").add("localOrigin","vec3").add("ambient","vec3").add("diffuse","vec3").add("opacity","float").add("layerOpacity","float"),a.hasColorTexture&&o.fragment.uniforms.add("tex","sampler2D"),o.include(C.PhysicallyBasedRenderingParameters,a),o.include(f.PhysicallyBasedRendering,a),o.include(O.MixExternalColor,{stages:1}),o.include(y.Normals,a),W.add(w.glsl(z||(z=e(["\n      void main() {\n        discardBySlice(vpos);\n        ","\n        shadingParams.viewDirection = normalize(vpos - camPos);\n        ","\n        ","\n        float ssao = evaluateAmbientOcclusionInverse();\n        ssao *= getBakedOcclusion();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n        ","\n        vec3 matColor = max(ambient, diffuse);\n        ","\n        ","\n        ","\n        ","\n        gl_FragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "],["\n      void main() {\n        discardBySlice(vpos);\n        ","\n        shadingParams.viewDirection = normalize(vpos - camPos);\n        ","\n        ","\n        float ssao = evaluateAmbientOcclusionInverse();\n        ssao *= getBakedOcclusion();\n\n        float additionalAmbientScale = _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight = ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n        ","\n        vec3 matColor = max(ambient, diffuse);\n        ","\n        ","\n        ","\n        ","\n        gl_FragColor = highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "])),a.hasColorTexture?w.glsl(E||(E=e(["\n        vec4 texColor = texture2D(tex, vuv0);\n        ","\n        discardOrAdjustAlpha(texColor);"],["\n        vec4 texColor = texture2D(tex, vuv0);\n        ","\n        discardOrAdjustAlpha(texColor);"])),a.textureAlphaPremultiplied?"texColor.rgb /= texColor.a;":""):w.glsl(_||(_=e(["vec4 texColor = vec4(1.0);"],["vec4 texColor = vec4(1.0);"]))),3===a.normalType?w.glsl(T||(T=e(["\n        vec3 normal = screenDerivativeNormal(localvpos);"],["\n        vec3 normal = screenDerivativeNormal(localvpos);"]))):w.glsl(D||(D=e(["\n        shadingParams.normalView = vNormalWorld;\n        vec3 normal = shadingNormal(shadingParams);"],["\n        shadingParams.normalView = vNormalWorld;\n        vec3 normal = shadingNormal(shadingParams);"]))),1===a.pbrMode?"applyPBRFactors();":"",a.receiveShadows?"float shadow = readShadowMap(vpos, linearDepth);":0===a.viewingMode?"float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);":"float shadow = 0.0;",a.attributeColor?w.glsl(V||(V=e(["\n        vec3 albedo_ = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));"],["\n        vec3 albedo_ = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));"]))):w.glsl(B||(B=e(["\n        vec3 albedo_ = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n        "],["\n        vec3 albedo_ = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n        "]))),a.hasNormalTexture?w.glsl(I||(I=e(["\n              mat3 tangentSpace = ","\n              vec3 shadedNormal = computeTextureNormal(tangentSpace, vuv0);"],["\n              mat3 tangentSpace = ","\n              vec3 shadedNormal = computeTextureNormal(tangentSpace, vuv0);"])),a.vertexTangets?"computeTangentSpace(normal);":"computeTangentSpace(normal, vpos, vuv0);"):"vec3 shadedNormal = normal;",1===a.pbrMode||2===a.pbrMode?0===a.viewingMode?w.glsl(F||(F=e(["vec3 normalGround = normalize(vpos + localOrigin);"],["vec3 normalGround = normalize(vpos + localOrigin);"]))):w.glsl(G||(G=e(["vec3 normalGround = vec3(0.0, 0.0, 1.0);"],["vec3 normalGround = vec3(0.0, 0.0, 1.0);"]))):w.glsl(R||(R=e([""],[""]))),1===a.pbrMode||2===a.pbrMode?w.glsl(j||(j=e(["\n            float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n            vec3 shadedColor = evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);"],["\n            float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n            vec3 shadedColor = evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);"]))):"vec3 shadedColor = evaluateSceneLighting(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight);"))),o.include(h.DefaultMaterialAuxiliaryPasses,a),o}}));