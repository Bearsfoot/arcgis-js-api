// COPYRIGHT Â© 2020 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.15/esri/copyright.txt for details.

define(["require","exports","../../../../../../../core/tsSupport/makeTemplateObjectHelper","../../../../../support/earthUtils","./ComponentData.glsl","./VertexDiscardByOpacity.glsl","../../../../core/shaderLibrary/ForwardLinearDepth.glsl","../../../../core/shaderLibrary/Slice.glsl","../../../../core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl","../../../../core/shaderLibrary/attributes/VertexColor.glsl","../../../../core/shaderLibrary/attributes/VertexNormal.glsl","../../../../core/shaderLibrary/attributes/VertexPosition.glsl","../../../../core/shaderLibrary/output/OutputDepth.glsl","../../../../core/shaderLibrary/output/OutputHighlight.glsl","../../../../core/shaderLibrary/shading/ComputeMaterialColor.glsl","../../../../core/shaderLibrary/shading/ComputeNormalTexture.glsl","../../../../core/shaderLibrary/shading/ComputeShadingNormal.glsl","../../../../core/shaderLibrary/shading/EvaluateSceneLighting.glsl","../../../../core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl","../../../../core/shaderLibrary/shading/ReadBaseColorTexture.glsl","../../../../core/shaderLibrary/shading/ReadShadowMap.glsl","../../../../core/shaderLibrary/util/AlphaDiscard.glsl","../../../../core/shaderModules/interfaces","../../../../core/shaderModules/ShaderBuilder","../../../../shaders/Overlay.glsl"],(function(e,a,o,r,n,l,t,i,d,s,c,g,v,u,m,h,C,p,x,b,y,w,f,S,O){var M,N,T,L,W,B,P,A,R,D,z,V,j,_,E,F,G,I,k,H,q,U,J,K,Q,X,Y,Z,$,ee,ae;Object.defineProperty(a,"__esModule",{value:!0}),a.attributeLocations={position:0,normal:1,normalCompressed:1,color:2,uv0:3,uvRegion:4,componentIndex:5},a.build=function(e){var a=new S.ShaderBuilder;a.include(g.VertexPosition,e),a.include(c.VertexNormal,e),a.include(s.VertexColor,e),a.include(d.TextureCoordinateAttribute,e),a.include(t.ForwardLinearDepth,e),a.include(n.ComponentData,e),a.include(w.DiscardOrAdjustAlpha,e),a.include(i.Slice,e),a.include(b.ReadBaseColorTexture,e),a.include(l.VertexDiscardByOpacity,e),1!==e.pbrMode&&2!==e.pbrMode||(a.include(x.PhysicallyBasedRenderingParameters,e),a.include(h.ComputeNormalTexture,e)),3===e.output&&1===e.componentData?a.vertex.code.add(f.glsl(M||(M=o(["\n      #define discardShadows(castShadows) { if(!castShadows) { gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }\n    "],["\n      #define discardShadows(castShadows) { if(!castShadows) { gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }\n    "])))):a.vertex.code.add(f.glsl(N||(N=o(["\n      #define discardShadows(castShadows) {}\n    "],["\n      #define discardShadows(castShadows) {}\n    "]))));var oe=e.overlayEnabled&&0===e.output&&4===e.pbrMode;return e.overlayEnabled&&(a.include(O.Overlay,e),0===e.viewingMode?a.vertex.code.add(f.glsl(T||(T=o(["\n      const float invEarthRadius = ",";\n      vec2 projectOverlay(vec3 pos) {\n        return pos.xy / (1.0 + invEarthRadius * pos.z);\n      }\n      "],["\n      const float invEarthRadius = ",";\n      vec2 projectOverlay(vec3 pos) {\n        return pos.xy / (1.0 + invEarthRadius * pos.z);\n      }\n      "])),f.glsl.float(1/r.earthRadius))):a.vertex.code.add(f.glsl(L||(L=o(["\n      vec2 projectOverlay(vec3 pos) { return pos.xy; }\n      "],["\n      vec2 projectOverlay(vec3 pos) { return pos.xy; }\n      "]))))),oe&&(a.varyings.add("tbnTangent","vec3"),a.varyings.add("tbnBiTangent","vec3"),a.varyings.add("groundNormal","vec3")),a.vertex.code.add(f.glsl(R||(R=o(["\n    void main() {\n      bool castShadows;\n      vec4 externalColor = forwardExternalColor(castShadows);\n      discardShadows(castShadows);\n\n      vertexDiscardByOpacity(externalColor.a);\n\n      if (externalColor.a < ",") {\n        // Discard this vertex\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n      forwardPosition();\n      forwardNormal();\n      ","\n\n      ","\n      forwardTextureCoordinates();\n      forwardVertexColor();\n      forwardLinearDepth(); // depends on forwardPosition()\n    }\n  "],["\n    void main() {\n      bool castShadows;\n      vec4 externalColor = forwardExternalColor(castShadows);\n      discardShadows(castShadows);\n\n      vertexDiscardByOpacity(externalColor.a);\n\n      if (externalColor.a < ",") {\n        // Discard this vertex\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n      forwardPosition();\n      forwardNormal();\n      ","\n\n      ","\n      forwardTextureCoordinates();\n      forwardVertexColor();\n      forwardLinearDepth(); // depends on forwardPosition()\n    }\n  "])),f.glsl.float(w.symbolAlphaCutoff),oe?f.glsl(P||(P=o(["\n        ","\n        "],["\n        ","\n        "])),0===e.viewingMode?f.glsl(W||(W=o(["\n        groundNormal = normalize(positionWorld());\n        tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));\n        tbnBiTangent = normalize(cross(groundNormal, tbnTangent));"],["\n        groundNormal = normalize(positionWorld());\n        tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));\n        tbnBiTangent = normalize(cross(groundNormal, tbnTangent));"]))):f.glsl(B||(B=o(["\n        groundNormal = vec3(0.0, 0.0, 1.0);\n        tbnTangent = vec3(1.0, 0.0, 0.0);\n        tbnBiTangent = normalize(cross(groundNormal, tbnTangent));"],["\n        groundNormal = vec3(0.0, 0.0, 1.0);\n        tbnTangent = vec3(1.0, 0.0, 0.0);\n        tbnBiTangent = normalize(cross(groundNormal, tbnTangent));"])))):"",e.overlayEnabled?f.glsl(A||(A=o(["setOverlayVTC(projectOverlay(position));"],["setOverlayVTC(projectOverlay(position));"]))):"")),0===e.output&&(a.include(m.ComputeMaterialColor,e),a.include(C.ComputeShadingNormal,e),a.include(p.EvaluateSceneLighting,e),oe&&(a.fragment.uniforms.add("ovInnerNormalTex","sampler2D"),a.fragment.uniforms.add("ovOuterNormalTex","sampler2D")),e.receiveShadows?(a.include(y.ReadShadowMap,e),a.fragment.code.add(f.glsl(D||(D=o(["\n        float evaluateShadow() {\n          return readShadowMap(vPositionWorldCameraRelative, linearDepth);\n        }\n      "],["\n        float evaluateShadow() {\n          return readShadowMap(vPositionWorldCameraRelative, linearDepth);\n        }\n      "]))))):a.fragment.code.add(f.glsl(z||(z=o(["\n        float evaluateShadow() { return 0.0; }\n      "],["\n        float evaluateShadow() { return 0.0; }\n      "])))),a.fragment.code.add(f.glsl(j||(j=o(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor = computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        ","\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor = computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        ","\n    "])),e.overlayEnabled?f.glsl(V||(V=o(["\n        vec4 overlayColor = getCombinedOverlayColor();\n        materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;"],["\n        vec4 overlayColor = getCombinedOverlayColor();\n        materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;"]))):"")),1===e.pbrMode||2===e.pbrMode?(a.fragment.code.add(f.glsl(E||(E=o(["\n        ","\n        vec3 normalVertex = shadingNormalWorld();\n        float additionalIrradiance = 0.02 * lightingMainIntensity[2];\n      "],["\n        ","\n        vec3 normalVertex = shadingNormalWorld();\n        float additionalIrradiance = 0.02 * lightingMainIntensity[2];\n      "])),1===e.pbrMode?f.glsl(_||(_=o(["\n        applyPBRFactors();\n        if (int(externalColorMixMode) == 3) {\n          mrr = vec3(0.0, 0.6, 0.2);\n        }"],["\n        applyPBRFactors();\n        if (int(externalColorMixMode) == 3) {\n          mrr = vec3(0.0, 0.6, 0.2);\n        }"]))):"")),e.hasNormalTexture?a.fragment.code.add(f.glsl(F||(F=o(["\n        mat3 tangentSpace = computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);\n        vec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);\n        "],["\n        mat3 tangentSpace = computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);\n        vec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);\n        "])))):a.fragment.code.add(f.glsl(G||(G=o(["\n        vec3 shadingNormal = normalVertex;\n        "],["\n        vec3 shadingNormal = normalVertex;\n        "])))),a.fragment.code.add(f.glsl(H||(H=o(["","\n      "],["","\n      "])),0===e.viewingMode?f.glsl(I||(I=o(["vec3 normalGround = normalize(positionWorld());"],["vec3 normalGround = normalize(positionWorld());"]))):f.glsl(k||(k=o(["vec3 normalGround = vec3(0.0, 0.0, 1.0);"],["vec3 normalGround = vec3(0.0, 0.0, 1.0);"]))))),a.fragment.code.add(f.glsl(q||(q=o(["\n        vec3 viewDir = normalize(vPositionWorldCameraRelative);\n        float ssao = 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());\n        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());\n        vec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);\n        "],["\n        vec3 viewDir = normalize(vPositionWorldCameraRelative);\n        float ssao = 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());\n        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());\n        vec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);\n        "]))))):(e.receiveShadows?a.fragment.code.add(f.glsl(U||(U=o(["\n      float shadow = evaluateShadow();\n        "],["\n      float shadow = evaluateShadow();\n        "])))):0===e.viewingMode?a.fragment.code.add(f.glsl(J||(J=o(["\n      float additionalAmbientScale = _oldHeuristicLighting(positionWorld());\n      float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n        "],["\n      float additionalAmbientScale = _oldHeuristicLighting(positionWorld());\n      float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);\n        "])))):a.fragment.code.add(f.glsl(K||(K=o(["\n      float shadow = 0.0;\n      "],["\n      float shadow = 0.0;\n      "])))),a.fragment.code.add(f.glsl(X||(X=o(["\n      float ambientOcclusion = evaluateAmbientOcclusion();\n      // At global scale we create some additional ambient light based on the main light to simulate global illumination\n      vec3 additionalLight = evaluateAdditionalLighting(ambientOcclusion, positionWorld());\n      vec4 shadedColor = vec4(evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight), materialColor.a);\n      ","\n      "],["\n      float ambientOcclusion = evaluateAmbientOcclusion();\n      // At global scale we create some additional ambient light based on the main light to simulate global illumination\n      vec3 additionalLight = evaluateAdditionalLighting(ambientOcclusion, positionWorld());\n      vec4 shadedColor = vec4(evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight), materialColor.a);\n      ","\n      "])),oe?f.glsl(Q||(Q=o(["\n          vec4 overlayWaterMask = getOverlayColor(ovInnerNormalTex, ovOuterNormalTex, vtcOverlay);\n          float waterNormalLength = length(overlayWaterMask);\n          if (waterNormalLength > 0.95) {\n            mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);\n            vec4 waterColor = getOverlayWaterColor(overlayWaterMask, overlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix);\n            // un-gamma the ground color to mix in linear space\n            vec4 groundColor = vec4(pow(shadedColor.rgb, vec3(2.2)), shadedColor.w);\n            waterColor = mix(groundColor, waterColor, waterColor.a);\n            shadedColor = vec4(delinearizeGamma(waterColor).rgb, materialColor.a);\n          }"],["\n          vec4 overlayWaterMask = getOverlayColor(ovInnerNormalTex, ovOuterNormalTex, vtcOverlay);\n          float waterNormalLength = length(overlayWaterMask);\n          if (waterNormalLength > 0.95) {\n            mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);\n            vec4 waterColor = getOverlayWaterColor(overlayWaterMask, overlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix);\n            // un-gamma the ground color to mix in linear space\n            vec4 groundColor = vec4(pow(shadedColor.rgb, vec3(2.2)), shadedColor.w);\n            waterColor = mix(groundColor, waterColor, waterColor.a);\n            shadedColor = vec4(delinearizeGamma(waterColor).rgb, materialColor.a);\n          }"]))):""))),a.fragment.code.add(f.glsl(Y||(Y=o(["\n        gl_FragColor = highlightSlice(shadedColor, vPositionWorldCameraRelative);\n      }\n    "],["\n        gl_FragColor = highlightSlice(shadedColor, vPositionWorldCameraRelative);\n      }\n    "]))))),1!==e.output&&3!==e.output||(a.include(v.OutputDepth,e),a.fragment.code.add(f.glsl(Z||(Z=o(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        outputDepth(linearDepth);\n      }\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        outputDepth(linearDepth);\n      }\n    "]))))),2===e.output&&(a.include(C.ComputeShadingNormal,e),a.fragment.code.add(f.glsl($||($=o(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        // note: the alpha component needs to be 1.0 in order for this material\n        // to influence ambient occlusion, see the ssao fragment shader\n        float alpha = ",";\n        gl_FragColor = vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);\n      }\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        // note: the alpha component needs to be 1.0 in order for this material\n        // to influence ambient occlusion, see the ssao fragment shader\n        float alpha = ",";\n        gl_FragColor = vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);\n      }\n    "])),2===e.normalType?"0.0":"1.0"))),4===e.output&&(a.include(u.OutputHighlight),a.fragment.code.add(f.glsl(ae||(ae=o(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        ","\n\n        outputHighlight();\n      }\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor = readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        ","\n\n        outputHighlight();\n      }\n    "])),e.overlayEnabled?f.glsl(ee||(ee=o(["\n        vec4 overlayColor = getCombinedOverlayColor();\n\n        if (overlayColor.a == 0.0) {\n          gl_FragColor = vec4(0.0);\n          return;\n        }"],["\n        vec4 overlayColor = getCombinedOverlayColor();\n\n        if (overlayColor.a == 0.0) {\n          gl_FragColor = vec4(0.0);\n          return;\n        }"]))):""))),a}}));